// Prisma schema for Holdwall POS
// Production-ready database schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// Authentication & Users
model User {
  id            String    @id @default(cuid())
  email         String    @unique
  name          String?
  passwordHash  String?
  image         String?
  emailVerified DateTime?
  role          UserRole  @default(USER)
  tenantId      String
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  accounts          Account[]
  sessions          Session[]
  pushSubscriptions PushSubscription[]
  tenant            Tenant             @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([email])
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model PushSubscription {
  id        String   @id @default(cuid())
  userId    String
  tenantId  String
  endpoint  String   @unique
  p256dhKey String
  authKey   String
  enabled   Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@unique([userId, endpoint])
  @@index([userId])
  @@index([tenantId])
  @@index([enabled])
}

enum UserRole {
  USER
  ADMIN
  APPROVER
  VIEWER
}

// Tenants
model Tenant {
  id        String   @id @default(cuid())
  name      String
  slug      String   @unique
  settings  Json?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  users                  User[]
  evidence               Evidence[]
  events                 Event[]
  claims                 Claim[]
  clusters               ClaimCluster[]
  nodes                  BeliefNode[]
  edges                  BeliefEdge[]
  forecasts              Forecast[]
  artifacts              AAALArtifact[]
  approvals              Approval[]
  playbooks              Playbook[]
  casePlaybookExecutions CasePlaybookExecution[]
  policies               SourcePolicy[]
  entitlements           Entitlement[]
  counters               MeteringCounter[]
  connectors             Connector[]
  apiKeys                ApiKey[]
  secrets                Secret[]
  aiAnswerSnapshots      AIAnswerSnapshot[]
  prompts                Prompt[]
  aiModels               AIModel[]
  citationRules          CitationRule[]
  pushSubscriptions      PushSubscription[]
  consensusSignals       ConsensusSignal[]
  externalValidators     ExternalValidator[]
  audits                 Audit[]
  slas                   SLA[]
  rebuttalDocuments      RebuttalDocument[]
  incidentExplanations   IncidentExplanation[]
  securityIncidents      SecurityIncident[]
  metricsDashboards      MetricsDashboard[]
  predictedComplaints    PredictedComplaint[]
  decisionCheckpoints    DecisionCheckpoint[]
  idempotencyKeys        IdempotencyKey[]
  evidenceVersions       EvidenceVersion[]
  evidenceAccessLogs     EvidenceAccessLog[]
  evidenceRedactions     EvidenceRedaction[]
  correctiveActions      CorrectiveAction[]
  preventiveActions      PreventiveAction[]
  actionOwners           ActionOwner[]
  changeEvents           ChangeEvent[]
  actionEvidence         ActionEvidence[]
  adversarialPatterns    AdversarialPattern[]
  sockpuppetClusters     SockpuppetCluster[]
  claimTemplates         ClaimTemplate[]
  crossPlatformCampaigns CrossPlatformCampaign[]
  customerResolutions    CustomerResolution[]
  remediationActions     RemediationAction[]
  supportTickets         SupportTicket[]
  entities               Entity[]
  entityEvents           EntityEvent[]
  entityRelationships    EntityRelationship[]
  workspaces             Workspace[]
  approvalWorkflows      ApprovalWorkflow[]
  approvalBreakGlasses   ApprovalBreakGlass[]
  cases                  Case[]
  caseTags               CaseTag[]
  caseWebhooks           CaseWebhook[]
  caseTemplates          CaseTemplate[]

  @@index([slug])
}

// Evidence Vault
model Evidence {
  id                   String           @id @default(cuid())
  tenantId             String
  type                 EvidenceType
  sourceType           String
  sourceId             String
  sourceUrl            String?
  collectedAt          DateTime
  collectedBy          String
  method               CollectionMethod
  contentRaw           String?          @db.Text
  contentNormalized    String?          @db.Text
  contentMetadata      Json?
  collectionMethod     String
  retentionPolicy      String
  complianceFlags      String[]
  signatureAlgorithm   String?
  signatureValue       String?          @db.Text
  signatureSignerId    String?
  metadata             Json?
  // Deduplication
  contentHash          String?          @db.VarChar(64)
  // Language detection
  detectedLanguage     String?
  languageConfidence   Float?
  // PII redaction
  piiRedacted          Boolean          @default(false)
  piiRedactionMap      Json?
  // Embedding storage (JSON array, primary storage in ChromaDB)
  embedding            Json?
  embeddingModel       String?
  embeddingGeneratedAt DateTime?
  createdAt            DateTime         @default(now())
  updatedAt            DateTime         @updatedAt

  tenant              Tenant                 @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  claimRefs           ClaimEvidence[]
  artifactRefs        AAALArtifactEvidence[]
  eventRefs           EventEvidence[]
  versions            EvidenceVersion[]
  accessLogs          EvidenceAccessLog[]
  redactions          EvidenceRedaction[]
  adversarialPatterns AdversarialPattern[]
  actionEvidence      ActionEvidence[]
  caseEvidence        CaseEvidence[]

  @@unique([tenantId, contentHash])
  @@index([tenantId])
  @@index([type])
  @@index([sourceType, sourceId])
  @@index([createdAt])
  @@index([contentHash])
}

// Evidence Versioning (Immutable)
model EvidenceVersion {
  id            String   @id @default(cuid())
  evidenceId    String
  tenantId      String
  versionNumber Int      @default(1)
  contentHash   String   @db.VarChar(64)
  merkleHash    String?  @db.VarChar(64)
  signature     String   @db.Text
  createdBy     String
  createdAt     DateTime @default(now())
  metadata      Json?

  evidence Evidence @relation(fields: [evidenceId], references: [id], onDelete: Cascade)
  tenant   Tenant   @relation(fields: [tenantId], references: [id])

  @@unique([evidenceId, versionNumber])
  @@index([evidenceId])
  @@index([tenantId])
  @@index([contentHash])
  @@index([createdAt])
}

// Evidence Access Log (Chain of Custody)
model EvidenceAccessLog {
  id         String             @id @default(cuid())
  evidenceId String
  tenantId   String
  actorId    String
  accessType EvidenceAccessType
  ipAddress  String?
  userAgent  String?
  reason     String?            @db.Text
  approvedBy String?
  createdAt  DateTime           @default(now())

  evidence Evidence @relation(fields: [evidenceId], references: [id], onDelete: Cascade)
  tenant   Tenant   @relation(fields: [tenantId], references: [id])

  @@index([evidenceId])
  @@index([tenantId])
  @@index([actorId])
  @@index([accessType])
  @@index([createdAt])
}

enum EvidenceAccessType {
  READ
  WRITE
  DELETE
  EXPORT
  REDACT
}

// Evidence Redaction (Audit Trail)
model EvidenceRedaction {
  id            String          @id @default(cuid())
  evidenceId    String
  tenantId      String
  redactedBy    String
  approvedBy    String?
  beforeContent String?         @db.Text
  afterContent  String?         @db.Text
  redactionMap  Json
  reason        String?         @db.Text
  status        RedactionStatus @default(PENDING)
  createdAt     DateTime        @default(now())
  approvedAt    DateTime?
  metadata      Json?

  evidence Evidence @relation(fields: [evidenceId], references: [id], onDelete: Cascade)
  tenant   Tenant   @relation(fields: [tenantId], references: [id])

  @@index([evidenceId])
  @@index([tenantId])
  @@index([status])
  @@index([createdAt])
}

enum RedactionStatus {
  PENDING
  APPROVED
  REJECTED
  APPLIED
}

enum EvidenceType {
  SIGNAL
  DOCUMENT
  ARTIFACT
  METRIC
  EXTERNAL
}

enum CollectionMethod {
  API
  RSS
  EXPORT
  MANUAL
}

// Events
model Event {
  id            String   @id @default(cuid())
  tenantId      String
  actorId       String
  type          String
  occurredAt    DateTime @default(now())
  correlationId String
  causationId   String?
  schemaVersion String   @default("1.0")
  payload       Json
  signatures    Json
  metadata      Json?
  createdAt     DateTime @default(now())

  tenant       Tenant          @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  evidenceRefs EventEvidence[]
  outbox       EventOutbox?

  @@index([tenantId])
  @@index([type])
  @@index([correlationId])
  @@index([occurredAt])
}

model EventEvidence {
  id         String @id @default(cuid())
  eventId    String
  evidenceId String

  event    Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  evidence Evidence @relation(fields: [evidenceId], references: [id], onDelete: Cascade)

  @@unique([eventId, evidenceId])
  @@index([eventId])
  @@index([evidenceId])
}

// Event Outbox (for reliable Kafka publishing)
model EventOutbox {
  id          String    @id @default(cuid())
  eventId     String    @unique
  tenantId    String
  topic       String
  partition   Int?
  key         String?
  value       String    @db.Text // JSON stringified event
  headers     Json?
  published   Boolean   @default(false)
  publishedAt DateTime?
  retryCount  Int       @default(0)
  lastError   String?   @db.Text
  createdAt   DateTime  @default(now())

  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@index([published])
  @@index([createdAt])
  @@index([tenantId])
}

// Event Processing (durable idempotency for workers)
model EventProcessing {
  id          String           @id @default(cuid())
  tenantId    String
  worker      String
  eventId     String
  status      ProcessingStatus @default(PROCESSING)
  attempt     Int              @default(1)
  startedAt   DateTime         @default(now())
  completedAt DateTime?
  lastError   String?          @db.Text

  @@unique([worker, eventId])
  @@index([tenantId])
  @@index([status])
  @@index([startedAt])
}

enum ProcessingStatus {
  PROCESSING
  COMPLETED
  FAILED
}

// Claims
model Claim {
  id            String   @id @default(cuid())
  tenantId      String
  canonicalText String   @db.Text
  variants      String[]
  decisiveness  Float
  clusterId     String?
  createdAt     DateTime @default(now())

  tenant         Tenant          @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  cluster        ClaimCluster?   @relation(fields: [clusterId], references: [id], onDelete: SetNull)
  evidenceRefs   ClaimEvidence[]
  asPrimaryClaim ClaimCluster?   @relation("PrimaryClaim")

  @@index([tenantId])
  @@index([clusterId])
  @@index([createdAt])
}

model ClaimEvidence {
  id         String @id @default(cuid())
  claimId    String
  evidenceId String

  claim    Claim    @relation(fields: [claimId], references: [id], onDelete: Cascade)
  evidence Evidence @relation(fields: [evidenceId], references: [id], onDelete: Cascade)

  @@unique([claimId, evidenceId])
  @@index([claimId])
  @@index([evidenceId])
}

model ClaimCluster {
  id             String   @id @default(cuid())
  tenantId       String
  primaryClaimId String   @unique
  size           Int
  decisiveness   Float
  createdAt      DateTime @default(now())

  tenant              Tenant               @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  primaryClaim        Claim                @relation("PrimaryClaim", fields: [primaryClaimId], references: [id], onDelete: Restrict)
  claims              Claim[]
  correctiveActions   CorrectiveAction[]
  preventiveActions   PreventiveAction[]
  customerResolutions CustomerResolution[]

  @@index([tenantId])
  @@index([createdAt])
}

// Belief Graph
model BeliefNode {
  id           String   @id @default(cuid())
  tenantId     String
  type         NodeType
  content      String   @db.Text
  trustScore   Float
  decisiveness Float
  actorWeights Json
  decayFactor  Float    @default(0.99)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  tenant    Tenant       @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  fromEdges BeliefEdge[] @relation("FromNode")
  toEdges   BeliefEdge[] @relation("ToNode")

  @@index([tenantId])
  @@index([type])
  @@index([createdAt])
}

enum NodeType {
  CLAIM
  EMOTION
  PROOF_POINT
  NARRATIVE
}

model BeliefEdge {
  id           String   @id @default(cuid())
  tenantId     String
  fromNodeId   String
  toNodeId     String
  type         EdgeType
  weight       Float
  actorWeights Json
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  tenant   Tenant     @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  fromNode BeliefNode @relation("FromNode", fields: [fromNodeId], references: [id], onDelete: Cascade)
  toNode   BeliefNode @relation("ToNode", fields: [toNodeId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([fromNodeId])
  @@index([toNodeId])
  @@index([type])
}

enum EdgeType {
  REINFORCEMENT
  NEUTRALIZATION
  DECAY
}

// Forecasts
model Forecast {
  id              String       @id @default(cuid())
  tenantId        String
  type            ForecastType
  targetMetric    String
  value           Float
  confidenceLower Float
  confidenceUpper Float
  confidenceLevel Float
  horizonDays     Int
  model           String
  evalScore       Float?
  createdAt       DateTime     @default(now())

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  // Type-specific fields (stored as JSON for flexibility)
  typeData Json?

  @@index([tenantId])
  @@index([type])
  @@index([createdAt])
}

enum ForecastType {
  DRIFT
  ANOMALY
  OUTBREAK
  DIFFUSION
}

// AAAL Artifacts
model AAALArtifact {
  id                String         @id @default(cuid())
  tenantId          String
  title             String
  content           String         @db.Text
  version           String
  status            ArtifactStatus
  approvers         String[]
  requiredApprovals Int
  policyChecks      Json?
  padlPublished     Boolean        @default(false)
  padlUrl           String?
  padlHash          String?
  padlRobots        String?
  createdAt         DateTime       @default(now())
  updatedAt         DateTime       @updatedAt
  publishedAt       DateTime?

  tenant       Tenant                 @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  evidenceRefs AAALArtifactEvidence[]
  approvals    Approval[]

  @@index([tenantId])
  @@index([status])
  @@index([createdAt])
}

model AAALArtifactEvidence {
  id         String @id @default(cuid())
  artifactId String
  evidenceId String

  artifact AAALArtifact @relation(fields: [artifactId], references: [id], onDelete: Cascade)
  evidence Evidence     @relation(fields: [evidenceId], references: [id], onDelete: Cascade)

  @@unique([artifactId, evidenceId])
  @@index([artifactId])
  @@index([evidenceId])
}

enum ArtifactStatus {
  DRAFT
  PENDING_APPROVAL
  APPROVED
  PUBLISHED
}

// Approvals
model Approval {
  id               String            @id @default(cuid())
  tenantId         String
  workspaceId      String?
  resourceType     String
  resourceId       String
  action           String
  requesterId      String
  approvers        String[]
  decision         ApprovalDecision?
  approverId       String?
  reason           String?           @db.Text
  artifactId       String?
  workflowId       String?
  currentStep      Int               @default(0)
  totalSteps       Int               @default(1)
  breakGlass       Boolean           @default(false)
  breakGlassReason String?           @db.Text
  breakGlassBy     String?
  breakGlassAt     DateTime?
  createdAt        DateTime          @default(now())
  decidedAt        DateTime?

  tenant             Tenant              @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  workspace          Workspace?          @relation(fields: [workspaceId], references: [id], onDelete: SetNull)
  artifact           AAALArtifact?       @relation(fields: [artifactId], references: [id], onDelete: Cascade)
  workflow           ApprovalWorkflow?   @relation(fields: [workflowId], references: [id], onDelete: SetNull)
  steps              ApprovalStep[]
  approvalBreakGlass ApprovalBreakGlass?

  @@index([tenantId])
  @@index([workspaceId])
  @@index([resourceType, resourceId])
  @@index([decision])
  @@index([createdAt])
}

enum ApprovalDecision {
  APPROVED
  REJECTED
}

model ApprovalStep {
  id           String             @id @default(cuid())
  approvalId   String
  stepNumber   Int
  approverId   String
  approverRole String?
  status       ApprovalStepStatus @default(PENDING)
  decision     ApprovalDecision?
  reason       String?            @db.Text
  decidedAt    DateTime?
  createdAt    DateTime           @default(now())
  updatedAt    DateTime           @updatedAt

  approval Approval @relation(fields: [approvalId], references: [id], onDelete: Cascade)

  @@unique([approvalId, stepNumber])
  @@index([approvalId])
  @@index([status])
  @@index([createdAt])
}

enum ApprovalStepStatus {
  PENDING
  APPROVED
  REJECTED
  SKIPPED
}

model ApprovalWorkflow {
  id           String   @id @default(cuid())
  tenantId     String
  name         String
  description  String?  @db.Text
  resourceType String
  action       String
  steps        Json // Array of step definitions
  isActive     Boolean  @default(true)
  metadata     Json?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  tenant    Tenant     @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  approvals Approval[]

  @@unique([tenantId, resourceType, action])
  @@index([tenantId])
  @@index([isActive])
}

model ApprovalBreakGlass {
  id            String   @id @default(cuid())
  approvalId    String   @unique
  tenantId      String
  triggeredBy   String
  reason        String   @db.Text
  justification String?  @db.Text
  metadata      Json?
  createdAt     DateTime @default(now())

  tenant   Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  approval Approval @relation(fields: [approvalId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([createdAt])
}

// Workspace Scoping
model Workspace {
  id        String        @id @default(cuid())
  tenantId  String
  name      String
  slug      String
  type      WorkspaceType @default(BRAND)
  region    String?
  metadata  Json?
  isActive  Boolean       @default(true)
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt

  tenant    Tenant          @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  approvals Approval[]
  users     WorkspaceUser[]

  @@unique([tenantId, slug])
  @@index([tenantId])
  @@index([type])
  @@index([isActive])
}

enum WorkspaceType {
  BRAND
  REGION
  DEPARTMENT
  PROJECT
  OTHER
}

model WorkspaceUser {
  id          String   @id @default(cuid())
  workspaceId String
  userId      String
  role        String?
  permissions String[]
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@unique([workspaceId, userId])
  @@index([workspaceId])
  @@index([userId])
}

// Playbooks
model Playbook {
  id            String        @id @default(cuid())
  tenantId      String
  name          String
  description   String?       @db.Text
  template      Json
  autopilotMode AutopilotMode
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt

  tenant         Tenant                  @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  executions     PlaybookExecution[]
  caseExecutions CasePlaybookExecution[]

  @@index([tenantId])
}

enum AutopilotMode {
  RECOMMEND_ONLY
  AUTO_DRAFT
  AUTO_ROUTE
  AUTO_PUBLISH
}

model PlaybookExecution {
  id          String          @id @default(cuid())
  playbookId  String
  status      ExecutionStatus
  result      Json?
  error       String?         @db.Text
  startedAt   DateTime        @default(now())
  completedAt DateTime?

  playbook Playbook @relation(fields: [playbookId], references: [id], onDelete: Cascade)

  @@index([playbookId])
  @@index([status])
  @@index([startedAt])
}

enum ExecutionStatus {
  PENDING
  RUNNING
  COMPLETED
  FAILED
  CANCELLED
}

// Source Compliance
model SourcePolicy {
  id               String           @id @default(cuid())
  tenantId         String
  sourceType       String
  allowedSources   String[]
  collectionMethod CollectionMethod
  retentionDays    Int
  autoDelete       Boolean
  complianceFlags  String[]
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@unique([tenantId, sourceType])
  @@index([tenantId])
}

// Metering
model Entitlement {
  id           String          @id @default(cuid())
  tenantId     String
  metric       String
  softLimit    Int
  hardLimit    Int
  currentUsage Int             @default(0)
  enforcement  EnforcementMode
  createdAt    DateTime        @default(now())
  updatedAt    DateTime        @updatedAt

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@unique([tenantId, metric])
  @@index([tenantId])
}

enum EnforcementMode {
  SOFT
  HARD
  NONE
}

model MeteringCounter {
  id        String        @id @default(cuid())
  tenantId  String
  metric    String
  value     Int           @default(0)
  period    CounterPeriod
  lastReset DateTime      @default(now())
  nextReset DateTime
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@unique([tenantId, metric, period])
  @@index([tenantId])
  @@index([nextReset])
}

enum CounterPeriod {
  DAY
  MONTH
  YEAR
}

// Connectors
model Connector {
  id         String          @id @default(cuid())
  tenantId   String
  type       String // "rss", "github", "s3", "webhook", etc.
  name       String
  status     ConnectorStatus @default(INACTIVE)
  config     Json // Connector-specific configuration
  apiKeyId   String? // Reference to API key (no plaintext secrets)
  lastSync   DateTime?
  lastError  String?         @db.Text
  errorCount Int             @default(0)
  cursor     String? // Checkpoint for incremental syncs
  schedule   String? // Cron expression for scheduled syncs
  enabled    Boolean         @default(true)
  createdAt  DateTime        @default(now())
  updatedAt  DateTime        @updatedAt

  tenant Tenant         @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  runs   ConnectorRun[]

  @@index([tenantId])
  @@index([type])
  @@index([status])
  @@index([enabled])
}

enum ConnectorStatus {
  ACTIVE
  INACTIVE
  ERROR
  SYNCING
}

model ConnectorRun {
  id             String    @id @default(cuid())
  connectorId    String
  status         RunStatus @default(PENDING)
  startedAt      DateTime  @default(now())
  completedAt    DateTime?
  itemsProcessed Int       @default(0)
  itemsCreated   Int       @default(0)
  itemsUpdated   Int       @default(0)
  itemsFailed    Int       @default(0)
  error          String?   @db.Text
  cursor         String? // Checkpoint after this run
  metadata       Json? // Run-specific metadata
  createdAt      DateTime  @default(now())

  connector Connector @relation(fields: [connectorId], references: [id], onDelete: Cascade)

  @@index([connectorId])
  @@index([status])
  @@index([startedAt])
}

enum RunStatus {
  PENDING
  RUNNING
  COMPLETED
  FAILED
  CANCELLED
}

// API Keys (for connector credentials)
model ApiKey {
  id        String    @id @default(cuid())
  tenantId  String
  name      String
  service   String // "openai", "github", "s3", etc.
  keyHash   String // Hashed key (never store plaintext)
  maskedKey String // Last 4 chars for display
  scopes    String[] // Permission scopes
  lastUsed  DateTime?
  expiresAt DateTime?
  revoked   Boolean   @default(false)
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([service])
  @@index([revoked])
}

// Secrets Management (encrypted storage)
model Secret {
  id                   String    @id @default(cuid())
  tenantId             String
  name                 String
  type                 String // "api_key", "password", "token", "certificate", "other"
  service              String?
  encryptedValue       String    @db.Text
  iv                   String // Initialization vector for encryption
  tag                  String // Authentication tag
  version              Int       @default(1)
  rotationPolicy       String    @default("manual") // "manual", "scheduled", "on-demand"
  rotationIntervalDays Int?
  lastRotated          DateTime?
  nextRotation         DateTime?
  accessCount          Int       @default(0)
  lastAccessed         DateTime?
  revoked              Boolean   @default(false)
  createdAt            DateTime  @default(now())
  updatedAt            DateTime  @updatedAt

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@unique([tenantId, name, version])
  @@index([tenantId])
  @@index([name])
  @@index([service])
  @@index([revoked])
  @@index([nextRotation])
}

// AI Answer Monitoring
model AIAnswerSnapshot {
  id        String   @id @default(cuid())
  tenantId  String
  engine    String
  query     String
  answer    String   @db.Text
  citations String[]
  tone      String?
  model     String?
  metadata  Json?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([engine])
  @@index([query])
  @@index([createdAt])
}

// Prompt Registry (AI Governance)
model Prompt {
  id           String    @id @default(cuid())
  tenantId     String
  name         String
  version      String // Semantic version (e.g., "1.0.0")
  content      String    @db.Text
  description  String?
  tags         String[]
  category     String? // "rag", "kag", "extraction", "evaluation", etc.
  model        String? // Recommended model
  temperature  Float?
  maxTokens    Int?
  parameters   Json? // Additional parameters
  policyChecks Json? // Policy validation results
  approved     Boolean   @default(false)
  approvedBy   String?
  approvedAt   DateTime?
  deprecated   Boolean   @default(false)
  deprecatedAt DateTime?
  usageCount   Int       @default(0)
  lastUsed     DateTime?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  tenant      Tenant             @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  evaluations PromptEvaluation[]

  @@unique([tenantId, name, version])
  @@index([tenantId])
  @@index([name])
  @@index([category])
  @@index([approved])
  @@index([deprecated])
}

// Golden Sets for AI Evaluation
model GoldenSet {
  id          String   @id @default(cuid())
  domain      String // "claims" | "evidence_linking" | "graph_updates" | "aaal_outputs"
  name        String
  version     String
  description String?  @db.Text
  examples    Json // Array of GoldenSetExample
  metadata    Json?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([domain, name, version])
  @@index([domain])
  @@index([name])
}

// Prompt Evaluation (for quality tracking)
model PromptEvaluation {
  id           String   @id @default(cuid())
  promptId     String
  evaluationId String? // Link to AIAnswerEvaluationHarness result
  score        Float // Overall quality score (0-1)
  metrics      Json // Detailed metrics (citation, accuracy, etc.)
  evaluator    String? // Model/service used for evaluation
  notes        String?  @db.Text
  createdAt    DateTime @default(now())

  prompt Prompt @relation(fields: [promptId], references: [id], onDelete: Cascade)

  @@index([promptId])
  @@index([score])
  @@index([createdAt])
}

// Model Registry (AI Governance)
model AIModel {
  id           String      @id @default(cuid())
  tenantId     String
  name         String // e.g., "gpt-4", "claude-3-opus"
  provider     String // "openai", "anthropic", "cohere", etc.
  version      String? // Model version/identifier
  status       ModelStatus @default(ACTIVE)
  capabilities String[] // ["text", "vision", "function-calling", etc.]
  rateLimit    Json? // Rate limit configuration
  costPerToken Json? // Pricing information
  policyChecks Json? // Policy validation results
  approved     Boolean     @default(false)
  approvedBy   String?
  approvedAt   DateTime?
  deprecated   Boolean     @default(false)
  deprecatedAt DateTime?
  usageCount   Int         @default(0)
  lastUsed     DateTime?
  createdAt    DateTime    @default(now())
  updatedAt    DateTime    @updatedAt

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@unique([tenantId, name, version])
  @@index([tenantId])
  @@index([name])
  @@index([provider])
  @@index([status])
  @@index([approved])
}

enum ModelStatus {
  ACTIVE
  DEPRECATED
  BLOCKED
}

// Citation Quality Rules (AI Governance)
model CitationRule {
  id               String           @id @default(cuid())
  tenantId         String
  name             String
  description      String?          @db.Text
  enabled          Boolean          @default(true)
  minCitations     Int              @default(1)
  maxCitations     Int? // Optional maximum
  requiredTypes    String[] // ["evidence", "claim", "forecast", etc.]
  qualityThreshold Float            @default(0.7) // Minimum quality score (0-1)
  enforcement      EnforcementLevel @default(WARNING)
  metadata         Json?
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([enabled])
  @@index([enforcement])
}

enum EnforcementLevel {
  WARNING // Log warning but allow
  BLOCK // Block publishing if violated
  REQUIRE_FIX // Require fix before publishing
}

// A2A (Agent-to-Agent Protocol) with OASF (Open Agentic Schema) support
model AgentRegistry {
  id           String   @id @default(cuid())
  agentId      String   @unique
  name         String
  version      String
  capabilities Json // Array of AgentCapability
  endpoint     String
  publicKey    String?  @db.Text
  metadata     Json? // Includes OASF AgentProfile
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@index([agentId])
  @@index([name])
}

model AgentConnection {
  id            String    @id @default(cuid())
  connectionId  String    @unique
  agentId       String
  peerAgentId   String
  status        String // "connecting" | "connected" | "disconnected" | "error"
  establishedAt DateTime  @default(now())
  lastHeartbeat DateTime?
  capabilities  Json // Array of AgentCapability
  metadata      Json?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  @@index([agentId])
  @@index([peerAgentId])
  @@index([status])
}

// ANP (Agent Network Protocol)
model AgentNetwork {
  id          String   @id @default(cuid())
  networkId   String   @unique
  name        String
  description String?  @db.Text
  agents      Json // Array of agent IDs
  topology    String // "mesh" | "star" | "hierarchical" | "ring"
  metadata    Json?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([networkId])
  @@index([topology])
}

// AG-UI (Agent-User Interaction Protocol)
model ConversationSession {
  id           String    @id @default(cuid())
  sessionId    String    @unique
  userId       String
  agentId      String
  startedAt    DateTime  @default(now())
  lastActivity DateTime  @default(now())
  endedAt      DateTime?
  messages     Json // Array of messages
  state        Json? // Session state
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  @@index([sessionId])
  @@index([userId])
  @@index([agentId])
  @@index([lastActivity])
}

// AP2 (Agent Payment Protocol)
model PaymentMandate {
  id          String    @id @default(cuid())
  mandateId   String    @unique
  fromAgentId String
  toAgentId   String
  type        String // "intent" | "cart" | "payment"
  amount      Int // in smallest currency unit (cents)
  currency    String    @db.VarChar(3)
  description String?   @db.Text
  metadata    Json?
  expiresAt   DateTime?
  status      String // "pending" | "approved" | "rejected" | "expired" | "revoked" | "completed"
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([mandateId])
  @@index([fromAgentId])
  @@index([toAgentId])
  @@index([status])
  @@index([expiresAt])
}

model PaymentSignature {
  id          String   @id @default(cuid())
  signatureId String   @unique
  mandateId   String
  agentId     String
  signature   String   @db.Text
  publicKey   String   @db.Text
  timestamp   DateTime @default(now())

  @@index([mandateId])
  @@index([agentId])
}

model WalletLedgerEntry {
  id            String   @id @default(cuid())
  entryId       String   @unique
  walletId      String
  agentId       String
  type          String // "credit" | "debit"
  amount        Int
  currency      String   @db.VarChar(3)
  mandateId     String?
  transactionId String?
  description   String?  @db.Text
  balance       Int // Balance after this entry
  timestamp     DateTime @default(now())

  @@index([walletId])
  @@index([agentId])
  @@index([currency])
  @@index([mandateId])
  @@index([transactionId])
  @@index([timestamp])
}

model WalletLimit {
  id           String   @id @default(cuid())
  walletId     String   @unique
  agentId      String
  limitType    String // "daily" | "weekly" | "monthly" | "transaction" | "lifetime"
  limitAmount  Int
  currency     String   @db.VarChar(3)
  currentUsage Int      @default(0)
  resetAt      DateTime
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@index([agentId])
  @@index([currency])
  @@index([resetAt])
}

model PaymentAuditLog {
  id            String   @id @default(cuid())
  auditId       String   @unique
  mandateId     String?
  transactionId String?
  action        String
  fromAgentId   String?
  toAgentId     String?
  amount        Int?
  currency      String?  @db.VarChar(3)
  status        String // "success" | "failure"
  error         String?  @db.Text
  metadata      Json?
  timestamp     DateTime @default(now())

  @@index([mandateId])
  @@index([transactionId])
  @@index([fromAgentId])
  @@index([toAgentId])
  @@index([action])
  @@index([timestamp])
}

// POS: Consensus Hijacking - Third-party validators and expert commentary
model ConsensusSignal {
  id               String              @id @default(cuid())
  tenantId         String
  type             ConsensusSignalType
  title            String
  content          String              @db.Text
  source           String // Third-party source name
  sourceUrl        String?
  author           String? // Expert/author name
  authorCredential String? // Author credentials/affiliation
  publishedAt      DateTime
  relevanceScore   Float               @default(0.5) // 0-1, how relevant to tenant
  trustScore       Float               @default(0.5) // 0-1, source trustworthiness
  amplification    Float               @default(0.0) // How much this amplifies consensus
  evidenceRefs     String[] // Evidence IDs this signal references
  relatedNodeIds   String[] // Belief node IDs this relates to
  metadata         Json?
  createdAt        DateTime            @default(now())
  updatedAt        DateTime            @updatedAt

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([type])
  @@index([publishedAt])
  @@index([relevanceScore])
  @@index([trustScore])
}

enum ConsensusSignalType {
  THIRD_PARTY_ANALYSIS
  EXPERT_COMMENTARY
  COMPARATIVE_RESEARCH
  BALANCED_PERSPECTIVE
  INDEPENDENT_REVIEW
}

// POS: External Validators
model ExternalValidator {
  id            String        @id @default(cuid())
  tenantId      String
  name          String
  type          ValidatorType
  description   String?       @db.Text
  url           String?
  publicKey     String?       @db.Text
  trustLevel    Float         @default(0.5) // 0-1
  isActive      Boolean       @default(true)
  lastValidated DateTime?
  metadata      Json?
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([type])
  @@index([isActive])
}

enum ValidatorType {
  INDEPENDENT_AUDIT
  CERTIFICATION_BODY
  EXPERT_PANEL
  RESEARCH_INSTITUTION
  STANDARDS_ORGANIZATION
}

// POS: Trust Substitution - Audits and SLAs
model Audit {
  id              String      @id @default(cuid())
  tenantId        String
  type            AuditType
  title           String
  description     String?     @db.Text
  auditorId       String? // External validator ID
  status          AuditStatus
  findings        Json? // Audit findings
  recommendations Json? // Recommendations
  publishedAt     DateTime?
  publicUrl       String?
  evidenceRefs    String[]
  metadata        Json?
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @default(now())
  completedAt     DateTime?

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([type])
  @@index([status])
  @@index([publishedAt])
}

enum AuditType {
  SECURITY
  COMPLIANCE
  OPERATIONAL
  FINANCIAL
  QUALITY
}

enum AuditStatus {
  PLANNED
  IN_PROGRESS
  COMPLETED
  PUBLISHED
}

model SLA {
  id          String    @id @default(cuid())
  tenantId    String
  name        String
  description String?   @db.Text
  metric      String // e.g., "uptime", "response_time"
  target      Float // Target value
  actual      Float? // Current actual value
  unit        String // e.g., "percent", "ms", "count"
  period      SLAPeriod
  publicUrl   String? // Public dashboard URL
  isPublic    Boolean   @default(false)
  lastUpdated DateTime  @default(now())
  metadata    Json?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([isPublic])
  @@index([lastUpdated])
}

enum SLAPeriod {
  HOURLY
  DAILY
  WEEKLY
  MONTHLY
  QUARTERLY
}

// POS: AI Answer Authority Layer - Rebuttal documents and incident explanations
model RebuttalDocument {
  id             String    @id @default(cuid())
  tenantId       String
  title          String
  content        String    @db.Text
  targetClaimId  String? // Claim this rebuts
  targetNodeId   String? // Belief node this addresses
  evidenceRefs   String[]
  structuredData Json? // Structured data for AI citation
  publicUrl      String?
  isPublished    Boolean   @default(false)
  publishedAt    DateTime?
  metadata       Json?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([targetClaimId])
  @@index([targetNodeId])
  @@index([isPublished])
}

model SecurityIncident {
  id                  String                   @id @default(cuid())
  tenantId            String
  externalId          String? // ID from external security tool (SIEM, SOAR, etc.)
  title               String
  description         String                   @db.Text
  type                SecurityIncidentType
  severity            SecurityIncidentSeverity
  status              SecurityIncidentStatus   @default(OPEN)
  detectedAt          DateTime
  resolvedAt          DateTime?
  source              String? // Source system (e.g., "Splunk", "CrowdStrike", "Custom")
  sourceMetadata      Json? // Additional metadata from source system
  narrativeRiskScore  Float? // Calculated narrative risk score (0-1)
  outbreakProbability Float? // Forecasted narrative outbreak probability
  evidenceRefs        String[] // References to evidence bundles
  explanationId       String?                  @unique // Link to IncidentExplanation if created
  aiCitationRate      Float? // AI citation rate for incident explanation
  metadata            Json?
  createdAt           DateTime                 @default(now())
  updatedAt           DateTime                 @updatedAt

  tenant      Tenant               @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  explanation IncidentExplanation? @relation("SecurityIncidentExplanation")

  @@index([tenantId])
  @@index([externalId])
  @@index([type])
  @@index([severity])
  @@index([status])
  @@index([detectedAt])
  @@index([narrativeRiskScore])
}

enum SecurityIncidentType {
  DATA_BREACH
  RANSOMWARE
  DDOS
  PHISHING
  MALWARE
  UNAUTHORIZED_ACCESS
  INSIDER_THREAT
  VULNERABILITY_EXPLOIT
  ACCOUNT_COMPROMISE
  SYSTEM_COMPROMISE
  OTHER
}

enum SecurityIncidentSeverity {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum SecurityIncidentStatus {
  OPEN
  INVESTIGATING
  CONTAINED
  RESOLVED
  CLOSED
}

model IncidentExplanation {
  id                 String    @id @default(cuid())
  tenantId           String
  incidentId         String? // Internal incident identifier (legacy support)
  securityIncidentId String?   @unique // Link to SecurityIncident (one-to-one relation)
  title              String
  summary            String    @db.Text
  explanation        String    @db.Text
  rootCause          String?   @db.Text
  resolution         String?   @db.Text
  prevention         String?   @db.Text
  evidenceRefs       String[]
  publicUrl          String?
  isPublished        Boolean   @default(false)
  publishedAt        DateTime?
  metadata           Json?
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt

  tenant           Tenant            @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  securityIncident SecurityIncident? @relation("SecurityIncidentExplanation", fields: [securityIncidentId], references: [id], onDelete: SetNull)

  @@index([tenantId])
  @@index([incidentId])
  @@index([securityIncidentId])
  @@index([isPublished])
}

model MetricsDashboard {
  id              String   @id @default(cuid())
  tenantId        String
  name            String
  description     String?  @db.Text
  metrics         Json // Array of metric definitions
  publicUrl       String?
  isPublic        Boolean  @default(false)
  refreshInterval Int? // Seconds
  lastRefreshed   DateTime @default(now())
  metadata        Json?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([isPublic])
}

// POS: Narrative Preemption Engine - Predictive complaint detection
model PredictedComplaint {
  id                 String           @id @default(cuid())
  tenantId           String
  predictedTopic     String
  predictedContent   String           @db.Text
  probability        Float // 0-1
  confidence         Float // 0-1
  horizonDays        Int // Days until predicted
  triggers           Json // Trigger conditions
  preemptiveActionId String? // Preemptive artifact/action ID
  status             PredictionStatus
  evidenceRefs       String[]
  metadata           Json?
  createdAt          DateTime         @default(now())
  updatedAt          DateTime         @updatedAt
  resolvedAt         DateTime?

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([status])
  @@index([probability])
  @@index([createdAt])
}

enum PredictionStatus {
  ACTIVE
  ADDRESSED
  FALSE_POSITIVE
  EXPIRED
}

// POS: Decision Funnel Domination - Decision checkpoints
model DecisionCheckpoint {
  id           String        @id @default(cuid())
  tenantId     String
  stage        DecisionStage
  checkpointId String // Unique identifier for this checkpoint
  name         String
  description  String?       @db.Text
  controlType  ControlType
  content      Json // Control content (narrative, proof, etc.)
  metrics      Json? // Metrics to track at this stage
  isActive     Boolean       @default(true)
  metadata     Json?
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([stage])
  @@index([isActive])
}

enum DecisionStage {
  AWARENESS
  RESEARCH
  COMPARISON
  DECISION
  POST_PURCHASE
}

enum ControlType {
  NARRATIVE_FRAMING
  AI_SUMMARY
  THIRD_PARTY_VALIDATOR
  PROOF_DASHBOARD
  REINFORCEMENT_LOOP
}

// Adversarial Detection
model AdversarialPattern {
  id          String   @id @default(cuid())
  tenantId    String
  evidenceId  String
  patternType String // "COORDINATED_AMPLIFICATION" | "SOCKPUPPET" | "CLAIM_TEMPLATE" | "CROSS_PLATFORM" | "MULTI"
  confidence  Float
  indicators  String[]
  metadata    Json?
  createdAt   DateTime @default(now())

  tenant   Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  evidence Evidence @relation(fields: [evidenceId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([evidenceId])
  @@index([patternType])
  @@index([createdAt])
}

model SockpuppetCluster {
  id         String   @id @default(cuid())
  tenantId   String
  clusterId  String   @unique
  accountIds String[]
  confidence Float
  indicators String[]
  metadata   Json?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([createdAt])
}

model ClaimTemplate {
  id            String   @id @default(cuid())
  tenantId      String
  templateId    String   @unique
  canonicalText String   @db.Text
  variants      String[]
  frequency     Int      @default(1)
  firstSeen     DateTime @default(now())
  lastSeen      DateTime @default(now())
  metadata      Json?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([templateId])
  @@index([lastSeen])
}

model CrossPlatformCampaign {
  id                 String   @id @default(cuid())
  tenantId           String
  campaignId         String   @unique
  platforms          String[]
  evidenceIds        String[]
  timingCorrelation  Float
  contentFingerprint String   @db.Text
  confidence         Float
  metadata           Json?
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([campaignId])
  @@index([createdAt])
}

// Customer Resolution Operations
model CustomerResolution {
  id                String             @id @default(cuid())
  tenantId          String
  clusterId         String
  type              ResolutionType
  status            ResolutionStatus   @default(OPEN)
  priority          ResolutionPriority @default(MEDIUM)
  title             String
  description       String             @db.Text
  customerInfo      Json?
  assignedTo        String?
  supportTicketId   String?            @unique
  externalTicketId  String?
  slaDeadline       DateTime?
  resolvedAt        DateTime?
  resolutionDetails String?            @db.Text
  metadata          Json?
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt

  tenant             Tenant              @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  cluster            ClaimCluster        @relation(fields: [clusterId], references: [id], onDelete: Cascade)
  supportTicket      SupportTicket?      @relation("SupportTicketResolution", fields: [supportTicketId], references: [id], onDelete: SetNull)
  remediationActions RemediationAction[]

  @@index([tenantId])
  @@index([clusterId])
  @@index([status])
  @@index([priority])
  @@index([assignedTo])
  @@index([createdAt])
}

enum ResolutionType {
  REFUND
  ESCALATION
  SUPPORT_TICKET
  APOLOGY
  CLARIFICATION
}

enum ResolutionStatus {
  OPEN
  IN_PROGRESS
  RESOLVED
  CLOSED
  ESCALATED
}

enum ResolutionPriority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

model RemediationAction {
  id                String            @id @default(cuid())
  resolutionId      String
  tenantId          String
  actionType        String
  description       String            @db.Text
  status            RemediationStatus @default(PENDING)
  assignedTo        String?
  dueDate           DateTime?
  completedAt       DateTime?
  verificationNotes String?           @db.Text
  metadata          Json?
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt

  tenant     Tenant             @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  resolution CustomerResolution @relation(fields: [resolutionId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([resolutionId])
  @@index([status])
  @@index([assignedTo])
  @@index([createdAt])
}

enum RemediationStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  VERIFIED
  FAILED
}

model SupportTicket {
  id             String   @id @default(cuid())
  tenantId       String
  resolutionId   String?  @unique
  externalSystem String // "zendesk", "jira", "servicenow", "internal"
  externalId     String?
  status         String   @default("OPEN")
  priority       String   @default("MEDIUM")
  metadata       Json?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  tenant     Tenant              @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  resolution CustomerResolution? @relation("SupportTicketResolution")

  @@index([tenantId])
  @@index([externalSystem])
  @@index([status])
  @@index([createdAt])
}

// Temporal Reasoning - Entity Tracking
model Entity {
  id           String     @id @default(cuid())
  tenantId     String
  type         EntityType
  name         String
  aliases      String[]
  currentState Json
  stateHistory Json // Array of state snapshots
  metadata     Json?
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt

  tenant        Tenant               @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  events        EntityEvent[]
  fromRelations EntityRelationship[] @relation("FromEntity")
  toRelations   EntityRelationship[] @relation("ToEntity")

  @@index([tenantId])
  @@index([type])
  @@index([name])
  @@index([createdAt])
}

enum EntityType {
  PERSON
  ORGANIZATION
  POLICY
  VENDOR
  SYSTEM
  OTHER
}

model EntityEvent {
  id           String   @id @default(cuid())
  tenantId     String
  entityId     String
  type         String // "CREATED" | "UPDATED" | "DELETED" | "STATE_CHANGED"
  oldState     Json?
  newState     Json
  changedBy    String
  changedAt    DateTime @default(now())
  changeReason String?  @db.Text
  metadata     Json?
  createdAt    DateTime @default(now())

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  entity Entity @relation(fields: [entityId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([entityId])
  @@index([type])
  @@index([changedAt])
}

model EntityRelationship {
  id               String   @id @default(cuid())
  tenantId         String
  fromEntityId     String
  toEntityId       String
  relationshipType String // "OWNS", "CHANGED", "REPORTS_TO", "WORKS_WITH", etc.
  strength         Float    @default(1.0)
  metadata         Json?
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  tenant     Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  fromEntity Entity @relation("FromEntity", fields: [fromEntityId], references: [id], onDelete: Cascade)
  toEntity   Entity @relation("ToEntity", fields: [toEntityId], references: [id], onDelete: Cascade)

  @@unique([fromEntityId, toEntityId, relationshipType])
  @@index([tenantId])
  @@index([fromEntityId])
  @@index([toEntityId])
  @@index([relationshipType])
}

// Idempotency Keys for ensuring operation idempotency
model IdempotencyKey {
  id        String   @id @default(cuid())
  key       String   @unique
  tenantId  String
  operation String
  result    String?  @db.Text
  expiresAt DateTime
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([operation])
  @@index([expiresAt])
}

// CAPA (Corrective Action and Preventive Action) Management
model CorrectiveAction {
  id            String         @id @default(cuid())
  tenantId      String
  clusterId     String
  title         String
  description   String         @db.Text
  status        ActionStatus   @default(OPEN)
  priority      ActionPriority @default(MEDIUM)
  ownerId       String?
  dueDate       DateTime?
  completedAt   DateTime?
  effectiveness Float? // 0-1 score
  metadata      Json?
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt

  tenant       Tenant           @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  cluster      ClaimCluster     @relation(fields: [clusterId], references: [id], onDelete: Cascade)
  owner        ActionOwner?     @relation(fields: [ownerId], references: [id], onDelete: SetNull)
  changeEvents ChangeEvent[]
  evidence     ActionEvidence[]

  @@index([tenantId])
  @@index([clusterId])
  @@index([status])
  @@index([ownerId])
  @@index([createdAt])
}

model PreventiveAction {
  id            String         @id @default(cuid())
  tenantId      String
  clusterId     String
  title         String
  description   String         @db.Text
  status        ActionStatus   @default(OPEN)
  priority      ActionPriority @default(MEDIUM)
  ownerId       String?
  dueDate       DateTime?
  completedAt   DateTime?
  effectiveness Float? // 0-1 score
  metadata      Json?
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt

  tenant       Tenant           @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  cluster      ClaimCluster     @relation(fields: [clusterId], references: [id], onDelete: Cascade)
  owner        ActionOwner?     @relation(fields: [ownerId], references: [id], onDelete: SetNull)
  changeEvents ChangeEvent[]
  evidence     ActionEvidence[]

  @@index([tenantId])
  @@index([clusterId])
  @@index([status])
  @@index([ownerId])
  @@index([createdAt])
}

enum ActionStatus {
  OPEN
  IN_PROGRESS
  COMPLETED
  CANCELLED
  VERIFIED
}

enum ActionPriority {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

model ActionOwner {
  id        String   @id @default(cuid())
  tenantId  String
  userId    String
  name      String
  email     String?
  role      String?
  metadata  Json?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tenant            Tenant             @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  correctiveActions CorrectiveAction[]
  preventiveActions PreventiveAction[]

  @@unique([tenantId, userId])
  @@index([tenantId])
  @@index([userId])
}

model ChangeEvent {
  id                 String          @id @default(cuid())
  tenantId           String
  type               ChangeEventType
  title              String
  description        String          @db.Text
  changedBy          String
  changedAt          DateTime        @default(now())
  correctiveActionId String?
  preventiveActionId String?
  metadata           Json?
  createdAt          DateTime        @default(now())

  tenant           Tenant            @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  correctiveAction CorrectiveAction? @relation(fields: [correctiveActionId], references: [id], onDelete: Cascade)
  preventiveAction PreventiveAction? @relation(fields: [preventiveActionId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([type])
  @@index([changedAt])
  @@index([correctiveActionId])
  @@index([preventiveActionId])
}

enum ChangeEventType {
  POLICY_REVISION
  VENDOR_TERMINATION
  LEADERSHIP_CHANGE
  CONTROL_ADDED
  PROCESS_CHANGE
  SYSTEM_UPDATE
  OTHER
}

model ActionEvidence {
  id                 String   @id @default(cuid())
  tenantId           String
  correctiveActionId String?
  preventiveActionId String?
  evidenceId         String
  relationship       String // "proves", "supports", "contradicts", etc.
  metadata           Json?
  createdAt          DateTime @default(now())

  tenant           Tenant            @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  correctiveAction CorrectiveAction? @relation(fields: [correctiveActionId], references: [id], onDelete: Cascade)
  preventiveAction PreventiveAction? @relation(fields: [preventiveActionId], references: [id], onDelete: Cascade)
  evidence         Evidence          @relation(fields: [evidenceId], references: [id], onDelete: Cascade)

  @@unique([correctiveActionId, evidenceId])
  @@unique([preventiveActionId, evidenceId])
  @@index([tenantId])
  @@index([evidenceId])
  @@index([correctiveActionId])
  @@index([preventiveActionId])
}

// Financial Services Trust & Resolution Desk - Case Management
// This file contains all Case-related models
// These models will be merged into the main schema.prisma file

model Case {
  id                    String        @id @default(cuid())
  tenantId              String
  caseNumber            String        @unique
  type                  CaseType
  status                CaseStatus    @default(SUBMITTED)
  severity              CaseSeverity  @default(MEDIUM)
  priority              CasePriority?
  submittedBy           String // Email or name
  submittedByEmail      String?
  submittedByName       String?
  description           String        @db.Text
  impact                String?       @db.Text
  preferredResolution   String?       @db.Text
  regulatorySensitivity Boolean       @default(false)
  slaDeadline           DateTime?
  assignedTo            String?
  assignedTeam          String?
  resolvedAt            DateTime?
  metadata              Json?
  createdAt             DateTime      @default(now())
  updatedAt             DateTime      @updatedAt

  tenant             Tenant                  @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  evidence           CaseEvidence[]
  resolution         CaseResolution?
  playbookExecutions CasePlaybookExecution[]
  comments           CaseComment[]
  tagAssignments     CaseTagAssignment[]
  notifications      CaseNotification[]
  verifications      CaseVerification[]
  escalations        CaseEscalation[]
  relationships      CaseRelationship[]      @relation("FromCase")
  relatedCases       CaseRelationship[]      @relation("ToCase")

  @@index([tenantId, status])
  @@index([tenantId, type])
  @@index([tenantId, severity])
  @@index([caseNumber])
  @@index([submittedBy])
  @@index([slaDeadline])
  @@index([priority])
  @@index([assignedTo])
  @@index([createdAt])
}

enum CaseType {
  DISPUTE
  FRAUD_ATO
  OUTAGE_DELAY
  COMPLAINT
}

enum CaseStatus {
  SUBMITTED
  TRIAGED
  IN_PROGRESS
  RESOLVED
  CLOSED
}

enum CaseSeverity {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum CasePriority {
  P0
  P1
  P2
  P3
}

model CaseEvidence {
  id           String           @id @default(cuid())
  caseId       String
  evidenceId   String
  evidenceType CaseEvidenceType
  role         CaseEvidenceRole @default(PRIMARY)
  createdAt    DateTime         @default(now())

  case     Case     @relation(fields: [caseId], references: [id], onDelete: Cascade)
  evidence Evidence @relation(fields: [evidenceId], references: [id], onDelete: Cascade)

  @@unique([caseId, evidenceId])
  @@index([caseId])
  @@index([evidenceId])
}

enum CaseEvidenceType {
  UPLOAD
  LINK
  INTERNAL_LOG
  TRANSACTION
}

enum CaseEvidenceRole {
  PRIMARY
  SUPPORTING
  REFUTATION
}

model CaseResolution {
  id                   String               @id @default(cuid())
  caseId               String               @unique
  customerPlan         Json // Step-by-step customer plan
  internalPlan         Json // Internal action plan
  recommendedDecision  String?
  evidenceChecklist    Json // Evidence checklist
  chargebackReadiness  Json? // Chargeback readiness (for disputes)
  safetySteps          Json? // Safety steps (for fraud)
  timeline             Json? // Timeline (for outages)
  resolutionArtifactId String? // Link to AAAL artifact
  internalPacketId     String? // Link to audit bundle
  status               CaseResolutionStatus @default(DRAFT)
  resolvedBy           String?
  resolvedAt           DateTime?
  createdAt            DateTime             @default(now())
  updatedAt            DateTime             @updatedAt

  case Case @relation(fields: [caseId], references: [id], onDelete: Cascade)

  @@index([caseId])
  @@index([status])
}

enum CaseResolutionStatus {
  DRAFT
  PENDING_APPROVAL
  APPROVED
  PUBLISHED
}

model CasePlaybookExecution {
  id          String   @id @default(cuid())
  caseId      String
  playbookId  String
  executionId String
  triggeredAt DateTime @default(now())
  result      Json?

  case     Case     @relation(fields: [caseId], references: [id], onDelete: Cascade)
  playbook Playbook @relation(fields: [playbookId], references: [id], onDelete: Cascade)
  tenant   Tenant?  @relation(fields: [tenantId], references: [id])
  tenantId String?

  @@index([caseId])
  @@index([playbookId])
  @@index([triggeredAt])
}

model CaseComment {
  id              String   @id @default(cuid())
  caseId          String
  authorId        String
  content         String   @db.Text
  isInternal      Boolean  @default(true)
  parentCommentId String?
  attachments     Json? // Array of file references
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  case          Case          @relation(fields: [caseId], references: [id], onDelete: Cascade)
  parentComment CaseComment?  @relation("CommentThread", fields: [parentCommentId], references: [id], onDelete: Cascade)
  replies       CaseComment[] @relation("CommentThread")

  @@index([caseId])
  @@index([authorId])
  @@index([createdAt])
  @@index([parentCommentId])
}

model CaseTag {
  id          String   @id @default(cuid())
  tenantId    String
  name        String
  color       String?  @default("#3B82F6")
  description String?  @db.Text
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  tenant      Tenant              @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  assignments CaseTagAssignment[]

  @@unique([tenantId, name])
  @@index([tenantId])
}

model CaseTagAssignment {
  id         String   @id @default(cuid())
  caseId     String
  tagId      String
  assignedAt DateTime @default(now())
  assignedBy String

  case Case    @relation(fields: [caseId], references: [id], onDelete: Cascade)
  tag  CaseTag @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@unique([caseId, tagId])
  @@index([caseId])
  @@index([tagId])
}

model CaseWebhook {
  id        String   @id @default(cuid())
  tenantId  String
  name      String
  url       String
  events    String[] // Array of event types
  secret    String?  @db.Text
  enabled   Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([enabled])
}

model CaseNotification {
  id          String                 @id @default(cuid())
  caseId      String
  recipient   String
  type        CaseNotificationType
  status      CaseNotificationStatus @default(PENDING)
  sentAt      DateTime?
  deliveredAt DateTime?
  openedAt    DateTime?
  createdAt   DateTime               @default(now())

  case Case @relation(fields: [caseId], references: [id], onDelete: Cascade)

  @@index([caseId])
  @@index([recipient])
  @@index([status])
}

enum CaseNotificationType {
  EMAIL
  PUSH
  SMS
}

enum CaseNotificationStatus {
  PENDING
  SENT
  DELIVERED
  OPENED
  FAILED
}

model CaseVerification {
  id         String                 @id @default(cuid())
  caseId     String
  method     CaseVerificationMethod
  status     CaseVerificationStatus @default(PENDING)
  verifiedAt DateTime?
  metadata   Json?
  createdAt  DateTime               @default(now())
  updatedAt  DateTime               @updatedAt

  case Case @relation(fields: [caseId], references: [id], onDelete: Cascade)

  @@index([caseId])
  @@index([status])
}

enum CaseVerificationMethod {
  EMAIL
  PHONE
  DOCUMENT
  ACCOUNT
}

enum CaseVerificationStatus {
  PENDING
  VERIFIED
  FAILED
  EXPIRED
}

model CaseEscalation {
  id          String    @id @default(cuid())
  caseId      String
  reason      String    @db.Text
  fromLevel   String
  toLevel     String
  escalatedBy String
  resolvedAt  DateTime?
  createdAt   DateTime  @default(now())

  case Case @relation(fields: [caseId], references: [id], onDelete: Cascade)

  @@index([caseId])
  @@index([createdAt])
}

model CaseTemplate {
  id          String   @id @default(cuid())
  tenantId    String
  name        String
  type        CaseType
  description String?  @db.Text
  template    Json // Template structure
  usageCount  Int      @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([type])
}

model CaseRelationship {
  id               String               @id @default(cuid())
  caseId           String
  relatedCaseId    String
  relationshipType CaseRelationshipType
  createdAt        DateTime             @default(now())

  case        Case @relation("FromCase", fields: [caseId], references: [id], onDelete: Cascade)
  relatedCase Case @relation("ToCase", fields: [relatedCaseId], references: [id], onDelete: Cascade)

  @@unique([caseId, relatedCaseId, relationshipType])
  @@index([caseId])
  @@index([relatedCaseId])
}

enum CaseRelationshipType {
  RELATED
  DUPLICATE
  PARENT
  CHILD
  LINKED
}
